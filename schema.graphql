# --- Safes & Users ---

type Safe @entity {
  " Equal to: <SafeHandler>-<CollateralType> "
  id: ID!

  " Safe ID if this Safe was created through the Safe Manager (GebSafeManager) "
  safeId: BigInt

  " Collateral type associated with this Safe "
  collateralType: CollateralType!

  " Amount of collateral locked in the Safe "
  collateral: BigDecimal!

  " Outstanding Safe debt "
  debt: BigDecimal!

  " The address of the Safe handler (ownership at the SAFEEngine level if the Safe was created using GebSafeManager) "
  safeHandler: Bytes!

  " Address of the Safe owner (top level ownership)"
  owner: User!

  " Optional proxy address (if the owner used a proxy to create the Safe) "
  proxy: UserProxy

  " Timestamp of the block at which this Safe was opened [seconds] "
  createdAt: BigInt!

  " Block number at which this Safe was opened "
  createdAtBlock: BigInt!

  " Hash of the transaction that opened the Safe "
  createdAtTransaction: Bytes!

  " Collateral balance of the safeHandler "
  internalCollateralBalance: InternalCollateralBalance

  " Coin balance of the safe handler "
  internalCoinBalance: InternalCoinBalance

  " Timestamp of the block at which this Safe was last modified [seconds] "
  modifiedAt: BigInt

  " Block number at which this Safe was last modified "
  modifiedAtBlock: BigInt

  " Hash of the transaction that last modified the Safe "
  modifiedAtTransaction: Bytes

  " List of CRatio changes "
  modifySAFECollateralization: [ModifySAFECollateralization!] @derivedFrom(field: "safe")

  " List of discount auctions associated with this Safe "
  liquidationDiscount: [DiscountAuction!] @derivedFrom(field: "safe")

  " List of English auctions associated with this Safe "
  liquidationEnglish: [EnglishAuction!] @derivedFrom(field: "safe")

  " Saviour contract helping to prevent liquidation"
  saviour: SafeSaviour
}

type User @entity {
  " Account ID "
  id: ID!

  " Account address "
  address: Bytes!

  " List of proxies associated with the user's address (for now limited to maximum one) "
  proxies: [UserProxy!] @derivedFrom(field: "owner")

  " List of Safes owned by this user "
  safes: [Safe!] @derivedFrom(field: "owner")

  " List of collateral balances "
  collateralBalance: [InternalCollateralBalance!] @derivedFrom(field: "owner")

  " List of system coin balances "
  coinBalance: [InternalCoinBalance!] @derivedFrom(field: "owner")

  " List of debt balances "
  debtBalance: [InternalDebtBalance!] @derivedFrom(field: "owner")

  " List of collateral deposits made into the system "
  collateralJoinTransactions: CollateralJoinTransaction @derivedFrom(field: "owner")

  " List of collateral withdrawals made out of the system "
  collateralExitTransactions: CollateralExitTransaction @derivedFrom(field: "owner")

  " List of system coin deposits made into the system "
  coinJoinTransactions: CoinJoinTransaction @derivedFrom(field: "owner")

  " List of system coin withdrawals made out of the system "
  coinExitTransactions: CoinExitTransaction @derivedFrom(field: "owner")
}

type UserProxy @entity {
  " Proxy address "
  id: ID!

  " Proxy contract address "
  address: Bytes!

  " Cache contract address "
  cache: Bytes!

  " Allowance of the proxy to spend its owner RAIs (Useful when we need to repay debt)"
  coinAllowance: ERC20Allowance

  " Allowance of the proxy to spend its owner prot tokens (Useful when we need to repay debt)"
  protAllowance: ERC20Allowance

  " Allowance of the proxy to spend its owner uni LP shares (Useful when we need to repay debt)"
  uniCoinLpAllowance: ERC20Allowance

  " Owner address "
  owner: User!
}

type SafeHandlerOwner @entity {
  # Used to look up the owner of a safeHandler. Only for Safes managed through the GebSafeManager

  " safeHandler address "
  id: ID!

  " Owner of the safeHandler address (if the Safe is owner by a proxy this will be the proxy's owner) "
  owner: User!
}

type ModifySAFECollateralization @entity {
  " Equal to: <TX hash>-<Log index> "
  id: ID!

  " Safe modified "
  safe: Safe!

  " safeHandler address (ownership at the SAFEEngine level) "
  safeHandler: Bytes!

  " Collateral type of the modification "
  collateralType: CollateralType!

  " Change in collateral "
  deltaCollateral: BigDecimal!

  " Change in debt "
  deltaDebt: BigDecimal!

  " Accumulated rate at the time of the transaction "
  accumulatedRate: BigDecimal!

  " Timestamp of the modification [seconds] "
  createdAt: BigInt!

  " Block number at which the modification happened "
  createdAtBlock: BigInt!

  " Hash of the transaction that made the modification "
  createdAtTransaction: Bytes!
}

type ConfiscateSAFECollateralAndDebt @entity {
  " Equal to: <TX hash>-<Log index> "
  id: ID!

  " Safe modified "
  safe: Safe!

  " safeHandler address (ownership at the SAFEEngine level) "
  safeHandler: Bytes!

  " Collateral type of the confisaction "
  collateralType: CollateralType!

  " Change in collateral "
  deltaCollateral: BigDecimal!

  " Change in debt "
  deltaDebt: BigDecimal!

  " Who to give/take the debt to "
  debtCounterparty: Bytes!

  " Who to give/take the collateral to "
  collateralCounterparty: Bytes!

  " Total amount of unbacked debt "
  globalUnbackedDebt: BigDecimal!

  " Timestamp of the confiscation [seconds] "
  createdAt: BigInt!

  " Block number at which the confiscation happened "
  createdAtBlock: BigInt!

  " Hash of the transaction that made the confiscation "
  createdAtTransaction: Bytes!
}

type TransferSAFECollateralAndDebt @entity {
  " Equal to: <TX hash>-<Log index> "
  id: ID!

  " Collateral type of the transfer "
  collateralType: CollateralType!

  " Destination safe "
  dstSafe: Safe!

  " Source safe "
  srcSafe: Safe!

  " Change in collateral "
  deltaCollateral: BigDecimal!

  " Change in debt "
  deltaDebt: BigDecimal!

  " Source safe handler "
  srcHandler: Bytes!

  " Destionation safe handler "
  dstHandler: Bytes!

  " Timestamp of the transfer [seconds] "
  createdAt: BigInt!

  " Block number at which the transfer happened "
  createdAtBlock: BigInt!

  " Hash of the transaction that made the transfer "
  createdAtTransaction: Bytes!
}

type SafeSaviour @entity {
  " Contract address "
  id: ID!

  " List of safe protected by the saviour "
  safes: [Safe!] @derivedFrom(field: "saviour")

  " If the saviour is currently allowed in the liquidation engine "
  allowed: Boolean!

  " Counter of successful save "
  successSaveCount: BigInt!

  " Counter of failed save "
  failSaveCount: BigInt!
}

type UpdateAccumulatedRate @entity {
  " Equal to: <TX hash>-<Log index> "
  id: ID!

  " Collateral type of the modification "
  collateralType: CollateralType!

  " Rate multiplier applied to globalDebt "
  rateMultiplier: BigDecimal!

  " Total accumulated rate "
  accumulatedRate: BigDecimal!

  " Global debt "
  globalDebt: BigDecimal!

  " Timestamp of the event [seconds] "
  createdAt: BigInt!

  " Block number at which the event happened "
  createdAtBlock: BigInt!

  " Hash of the transaction that made the event "
  createdAtTransaction: Bytes!
}

# --- System state --

type CollateralType @entity {
  " Collateral type name "
  id: ID!

  # == Safe stats ==

  " Total debt backed by this collateral type "
  debtAmount: BigDecimal!

  " Total collateral deposited in the system (deposited in this collateral's specific adapter) "
  totalCollateral: BigDecimal!

  " Total collateral deposited in the system and locked in Safes "
  totalCollateralLockedInSafes: BigDecimal!

  " Total interest accrued on this collateral type "
  accumulatedRate: BigDecimal!

  " Number of Safes backed by this collateral type and NOT opened through the manager (GebSafeManager) "
  unmanagedSafeCount: BigInt!

  " Number of Safes backed by this collateral type that were opened through the manager (GebSafeManager) "
  safeCount: BigInt!

  # == Prices ==

  " Current market price "
  currentPrice: CollateralPrice

  " Latest Coin FSM update "
  currentFsmUpdate: FsmUpdate

  # == Constants ==

  " Address of the FSM contract used for this collateral type "
  fsmAddress: Bytes

  " Per second stability fee "
  stabilityFee: BigDecimal!

  " Total annualized stability calculated with solidity. It takes into account the global SF. Equals to (global SF + collateral SF)^(second per year)"
  totalAnnualizedStabilityFee: BigDecimal!

  " Debt ceiling/upper limit "
  debtCeiling: BigDecimal!

  " Minimum permitted debt per Safe/lower limit "
  debtFloor: BigDecimal!

  " Collateral price with safety margin. Used to limit the amount of debt that can be generated per one unit of collateral "
  safetyCRatio: BigDecimal!

  " Collateral price with liquidation margin. Used only in LiquidationEngine when a Safe is liquidated "
  liquidationCRatio: BigDecimal!

  # == Auction/Liquidations ==

  " Penalty applied to every liquidation involving this collateral type "
  liquidationPenalty: BigDecimal!

  " Address of the auction smart contract handling this collateral type "
  collateralAuctionHouseAddress: Bytes!

  " Type of collateral auction "
  auctionType: AuctionType

  " Max amount of system coins to sell in one auction "
  liquidationQuantity: BigDecimal

  " Number of liquidations started "
  liquidationsStarted: BigInt!

  " Number of active liquidations "
  activeLiquidations: BigInt!

  " Auction configuration (English only) "
  englishAuctionConfiguration: EnglishAuctionConfiguration

  # == Time ==

  " Time of the last stability fee update "
  stabilityFeeLastUpdatedAt: BigInt!

  " Timestamp of the block at which this collateral type was added [seconds] "
  createdAt: BigInt!

  " Block number at which this collateral type was added "
  createdAtBlock: BigInt!

  " Hash of the transaction that added this collateral type "
  createdAtTransaction: Bytes!

  " Timestamp of the block at which this collateral type was last modified [seconds] "
  modifiedAt: BigInt

  " Block number at which this collateral type was last modified "
  modifiedAtBlock: BigInt

  " Hash of the transaction that last modified this collateral type "
  modifiedAtTransaction: Bytes
}

type SystemState @entity {
  " Singleton entity. Always set to 'current' "
  id: ID!

  " Number of Safes opened through the manager (GebSafeManager) "
  safeCount: BigInt!

  " Number of Safes NOT opened through the manager (GebSafeManager) "
  unmanagedSafeCount: BigInt!

  " Total number of Safes with debt > 0 and/or collateral > 0"
  totalActiveSafeCount: BigInt!

  " Number of user proxies created "
  proxyCount: BigInt!

  " Total debt issued across all collateral types "
  globalDebt: BigDecimal!

  " Global debt from 24h ago to calculate 24h TVL % change "
  globalDebt24hAgo: BigDecimal!

  " Total unbacked debt across all collateral types "
  globalUnbackedDebt: BigDecimal!

  " Global debt ceiling "
  globalDebtCeiling: BigDecimal!

  " Individual safe debt limit "
  perSafeDebtCeiling: BigDecimal!

  " Number of collateral types registered "
  collateralCount: BigInt!

  " Base per second stability fee applied to all collateral types "
  globalStabilityFee: BigDecimal!

  " Savings rate "
  savingsRate: BigDecimal!

  " Number of collateral auctions started "
  collateralAuctionCount: BigInt!

  " Latest redemption rate"
  currentRedemptionRate: RedemptionRate

  " Latest redemption price "
  currentRedemptionPrice: RedemptionPrice

  " Latest Coin medianizer update "
  currentCoinMedianizerUpdate: MedianizerUpdate

  " Total supply of COIN outside of the system, equals to ERC20.totalSupply() of Coin "
  erc20CoinTotalSupply: BigDecimal!

  " Last time the periodic update function was called"
  lastPeriodicUpdate: BigInt!

  " Timestamp of the block at which the system was created [seconds] "
  createdAt: BigInt!

  " Coin contract address "
  coinAddress: Bytes!

  " WETH collateral address "
  wethAddress: Bytes!

  " Coin uniswap pair address "
  coinUniswapPair: UniswapPair

  " System surplus in the accounting engine "
  systemSurplus: BigDecimal!

  " Debt available to settle in the accounting engine "
  debtAvailableToSettle: BigDecimal!

  " Block number at which the system was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that started to create the system "
  createdAtTransaction: Bytes!

  " Timestamp of the block at which the system was last modified [seconds] "
  modifiedAt: BigInt

  " Block number at which the system was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash at which the system was last modified "
  modifiedAtTransaction: Bytes
}

type AccountingEngine @entity {
  " Always set th 'current' "
  id: ID!

  " Total debt in the queue (that the system tries to cover with collateral auctions) "
  totalQueuedDebt: BigDecimal!

  " Total debt being auctioned in DebtAuctionHouse "
  totalOnAuctionDebt: BigDecimal!

  " When the last surplus auction was triggered "
  lastSurplusAuctionTime: BigInt

  " Delay between surplus auctions "
  surplusAuctionDelay: BigInt!

  " Delay after which debt can be popped from the debtQueue (from the moment it's added) "
  popDebtDelay: BigInt!

  " Amount of protocol tokens to be minted after a debt auction "
  initialDebtAuctionMintedTokens: BigDecimal!

  " Amount of debt sold in one debt auction "
  debtAuctionBidSize: BigDecimal!

  " Amount of surplus stability fees sold in one surplus auction "
  surplusAuctionAmountToSell: BigDecimal!

  " Amount of stability fees that need to accrue in the engine before any surplus auction can start "
  surplusBuffer: BigDecimal!

  " Time to wait (post settlement) until any remaining surplus can be transferred to the settlement surplus auctioneer "
  disableCooldown: BigInt!

  " When the contract was disabled "
  disableTimestamp: BigInt

  " Whether this contract is enabled or not "
  contractEnabled: Boolean!

  " Safe database "
  safeEngine: Bytes!

  " Contract that handles auctions for surplus stability fees "
  surplusAuctionHouse: Bytes!

  " Number debt auctions since the beginning "
  debtAuctionCount: BigInt!

  " Number debt auctions since the beginning "
  surplusAuctionCount: BigInt!

  " Currently ongoing debt auction "
  activeDebtAuctions: BigInt!

  " Currently ongoing surplus auction "
  activeSurplusAuctions: BigInt!

  " Contract that handles auctions for debt that couldn't be covered by collateral auctions "
  debtAuctionHouse: Bytes!

  " Permissions registry dictating who can burn and mint protocol tokens "
  protocolTokenAuthority: Bytes!

  " Addredd of the contract that auctions extra surplus after settlement is triggered "
  postSettlementSurplusDrain: Bytes!

  " Timestamp of the block at which the Accounting engine was last modified [seconds] "
  modifiedAt: BigInt

  " Block number at which the Accounting engine was last modified "
  modifiedAtBlock: BigInt

  " Hash of the transaction that last modified the accounting engine "
  modifiedAtTransaction: Bytes
}

# --- Balances & Deposits/Withdrawals ---

type InternalCollateralBalance @entity {
  " Equal to: <accountHandler>-<CollateralType> "
  id: ID!

  " Account ownership at the SafeEngine level "
  accountHandler: Bytes!

  " Ultimate owner of the balance "
  owner: User!

  " Collateral type "
  collateralType: CollateralType!

  " Proxy address (if the balance belongs to a proxy) "
  proxy: UserProxy

  " Actual balance "
  balance: BigDecimal!

  " Timestamp of the block at which this balance was created [seconds] "
  createdAt: BigInt!

  " Block number at which this balance was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that created this balance "
  createdAtTransaction: Bytes!

  " Timestamp of the block at which this balance was last modified [seconds] "
  modifiedAt: BigInt

  " Block number at which this balance was last modified "
  modifiedAtBlock: BigInt

  " Hash of the transaction that last modified this transaction "
  modifiedAtTransaction: Bytes
}

type InternalCoinBalance @entity {
  " Equals to: <accountHandler> "
  id: ID!

  " Account ownership at the SafeEngine level "
  accountHandler: Bytes!

  " Ultimate owner of the balance (the accountHandler or the proxy)"
  owner: User!

  " Proxy address (if the balance belongs to a proxy) "
  proxy: UserProxy

  " Actual balance "
  balance: BigDecimal!

  " Timestamp of the block at which this balance was first created [seconds] "
  createdAt: BigInt!

  " Block number at which this balance was first created "
  createdAtBlock: BigInt!

  " Hash of the transaction that first created this balance "
  createdAtTransaction: Bytes!

  " Timestamp of the block at which this balance was last modified [seconds] "
  modifiedAt: BigInt

  " Block number at which this balance was last modified "
  modifiedAtBlock: BigInt

  " Hash of the transaction that last modified this balance "
  modifiedAtTransaction: Bytes
}

type InternalDebtBalance @entity {
  " Equal to: <accountHandler> "
  id: ID!

  " Account ownership at the SafeEngine level "
  accountHandler: Bytes!

  " Ultimate owner of the balance (the accountHandler or the proxy)"
  owner: User!

  " Actual balance "
  balance: BigDecimal!

  " Timestamp of the block at which this balance was created [seconds] "
  createdAt: BigInt!

  " Block number at which this balance was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that first created this balance "
  createdAtTransaction: Bytes!

  " Timestamp of the block at which this balance was last modified [seconds] "
  modifiedAt: BigInt

  " Block number in which this balance was last modified "
  modifiedAtBlock: BigInt

  " Hash of the transaction that last modified this balance "
  modifiedAtTransaction: Bytes
}

type CollateralJoinTransaction @entity {
  "Equal to: <TX hash>-<Log index>"
  id: ID!

  " Joined amount "
  amount: BigDecimal!

  " Safe handler being credited "
  safeHandler: Bytes!

  " Owner of the safeHandler "
  owner: User!

  " Source of the collateral"
  source: Bytes!

  " Collateral type handled by the CollateralJoin contract "
  collateralType: CollateralType!

  " Timestamp of the block at which this join action happened [seconds] "
  createdAt: BigInt!

  " Block number at which this join action happened "
  createdAtBlock: BigInt!

  " Hash of the join transaction "
  createdAtTransaction: Bytes!
}

type CollateralExitTransaction @entity {
  "<TX hash>-<Log index>"
  id: ID!

  " Exited amount "
  amount: BigDecimal!

  " Safe handler being debited "
  safeHandler: Bytes

  " Owner of the safeHandler "
  owner: User!

  " Account receiving the exited collateral "
  recipient: Bytes!

  " Collateral type exited "
  collateralType: CollateralType!

  " Timestamp of the block at which this exit was executed [seconds] "
  createdAt: BigInt!

  " Block number at which this exit was executed "
  createdAtBlock: BigInt!

  " Transaction hash at which this exit was executed "
  createdAtTransaction: Bytes!
}

type CoinJoinTransaction @entity {
  "Equal to: <TX hash>-<Log index>"
  id: ID!

  " Joined amount "
  amount: BigDecimal!

  " Safe handler being credited "
  safeHandler: Bytes!

  " Owner of the safeHandler "
  owner: User!

  " Source address of the coins "
  source: Bytes!

  " Timestamp of the block at which this transaction was executed [seconds] "
  createdAt: BigInt!

  " Block number at which this transaction was executed "
  createdAtBlock: BigInt!

  " Hash of the transaction that executed the join "
  createdAtTransaction: Bytes!
}

type CoinExitTransaction @entity {
  "<TX hash>-<Log index>"
  id: ID!

  " Exited amount "
  amount: BigDecimal!

  " Safe handler owning the balance at the SAFEEngine level "
  safeHandler: Bytes!

  " Owner of the safeHandler "
  owner: User!

  " Account that received the coins "
  recipient: Bytes!

  " Timestamp of the block at which this transaction was executed [seconds] "
  createdAt: BigInt!

  " Block number at which this transaction was executed "
  createdAtBlock: BigInt!

  " Hash of the transaction that executed this exit "
  createdAtTransaction: Bytes!
}

# --- Prices ---
type CollateralPrice @entity {
  " Equal to: <tx hash>-<log index>"
  id: ID!

  " Block number "
  block: BigInt!

  " Timestamp in seconds "
  timestamp: BigInt!

  " Collateral type "
  collateral: CollateralType!

  " Price of the collateral divided by the redemptionPrice and then divided again by the safetyCRatio "
  safetyPrice: BigDecimal!

  " Price of the collateral divided by the redemptionPrice and then divided again by the liquidationCRatio "
  liquidationPrice: BigDecimal!

  " Collateral price in denomination currency "
  value: BigDecimal!
}

type RedemptionPrice @entity {
  " Equals to: <tx hash>-<log index>"
  id: ID!

  " Block number "
  block: BigInt!

  " Timestamp in seconds "
  timestamp: BigInt!

  " The rate of change of the redemption price "
  redemptionRate: BigDecimal!

  " Redemption price value "
  value: BigDecimal!
}

type RedemptionRate @entity {
  " Equal to: <tx hash>-<log index>"
  id: ID!

  " The rate of change of the redemption price "
  perSecondRate: BigDecimal!

  " 8 hour redemption rate "
  eightHourlyRate: BigDecimal!

  " 24 hour redemption rate "
  twentyFourHourlyRate: BigDecimal!

  " One hour redemption rate "
  hourlyRate: BigDecimal!

  " Annualized redemption rate "
  annualizedRate: BigDecimal!

  " Timestamp of the block at which this rate was created [seconds] "
  createdAt: BigInt!

  " Block number at which this rate was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that created this rate "
  createdAtTransaction: Bytes!
}

# --- Oracles ---

type FsmUpdate @entity {
  " Equal to: <tx hash>-<log index>"
  id: ID!

  " FSM address "
  fsmAddress: Bytes!

  " Price of the update "
  value: BigDecimal!

  " Next price update "
  nextValue: BigDecimal!

  " Next update timestamp "
  nextUpdateMinTimestamp: BigInt!

  " Timestamp of the block at which this transaction was executed [seconds] "
  createdAt: BigInt!

  " Block number at which this transaction was executed "
  createdAtBlock: BigInt!

  " Hash of the transaction that executed this exit "
  createdAtTransaction: Bytes!
}

type MedianizerUpdate @entity {
  " Equal to: <tx hash>-<log index>"
  id: ID!

  " FSM address "
  medianizerAddress: Bytes!

  " Price pair symbol"
  symbol: String!

  " The rate of change of the redemption price "
  value: BigDecimal!

  " Timestamp of the block at which this transaction was executed [seconds] "
  createdAt: BigInt!

  " Block number at which this transaction was executed "
  createdAtBlock: BigInt!

  " Hash of the transaction that executed this exit "
  createdAtTransaction: Bytes!
}

# --- Auctions ---

enum AuctionType {
  ENGLISH
  FIXED_DISCOUNT
  INCREASING_DISCOUNT
}

type EnglishAuctionConfiguration @entity {
  " Collateral type name, 'DEBT' or 'SURPLUS' "
  id: ID!

  " Collateral type "
  LIQUIDATION_collateralType: CollateralType

  " Minimum bid increase (e.g 1.05 means a minimum 5% increase for the next bid compared to the current one) "
  bidIncrease: BigDecimal!

  " How long the auction lasts after a new bid is submitted "
  bidDuration: BigInt

  " Maximum auction length "
  totalAuctionLength: BigInt!

  " Increase in amount sold upon auction restart (used only for DEBT auctions) "
  DEBT_amountSoldIncrease: BigDecimal
}

type EnglishAuctionBid @entity {
  " Collateral type name or 'DEBT', 'SURPLUS_PRE' or 'SURPLUS_POST'. Equal to: <collateral type>-<auction id>-<bid number> "
  id: ID!

  " Incremental bid id "
  bidNumber: BigInt!

  " Bid type, either increase buy or decrease sell "
  type: EnglishBidType!

  " Auction to which the bid belongs (if it's a bid on a collateral auction) "
  auction: EnglishAuction

  " How many tokens/coins are sold in the auction "
  sellAmount: BigDecimal!

  " How many tokens are being bought from the auction "
  buyAmount: BigDecimal!

  " Price of the asset being sold (sellAmount / buyAmount) "
  price: BigDecimal!

  " Bidder address "
  bidder: Bytes

  " Timestamp of the block at which the liquidation started "
  createdAt: BigInt!

  " Block number at which the liquidation started "
  createdAtBlock: BigInt!

  " Hash of the transaction that started the liquidation "
  createdAtTransaction: Bytes!
}

# --- English Auction ---

enum EnglishAuctionType {
  LIQUIDATION
  DEBT
  SURPLUS
  STAKED_TOKEN
}

enum AuctionToken {
  COIN
  COLLATERAL
  PROTOCOL_TOKEN
  PROTOCOL_TOKEN_LP
}

enum EnglishBidType {
  INCREASE_BUY
  DECREASE_SOLD
}

type EnglishAuction @entity {
  " Collateral type name or 'DEBT', 'SURPLUS_PRE' or 'SURPLUS_POST'. Equal toL <collateral type>-<auction id> "
  id: ID!

  " Incremental auction id "
  auctionId: BigInt!

  " Whether the auction handles collateral, surplus or debt "
  englishAuctionType: EnglishAuctionType!

  " Token/coin being sold "
  sellToken: AuctionToken!

  " Token/coin being bought "
  buyToken: AuctionToken!

  " Amount of tokens that the system is selling at the start of the auction  "
  sellInitialAmount: BigDecimal!

  " Amount of tokens that the system is buying at the start of the auction  "
  buyInitialAmount: BigDecimal!

  " Amount of tokens that the system is currently selling in the auction "
  sellAmount: BigDecimal!

  " Amount of tokens that that are currently being bought in the auction "
  buyAmount: BigDecimal!

  " Sell price (sellAmount / buyAMount) of the best offer "
  price: BigDecimal

  " Used for collateral auctions only. Threshold of buyToken at which the system starts to decrease the amount sold "
  targetAmount: BigDecimal

  " Auction winner "
  winner: Bytes

  " Address that started the auction "
  startedBy: Bytes!

  " Whether the bought tokens were claimed by the auction winner "
  isClaimed: Boolean!

  " Total number of bids "
  numberOfBids: BigInt!

  " Deadline for the auction after which no more bids can be placed  "
  auctionDeadline: BigInt!

  " List of individual bids "
  englishAuctionBids: [EnglishAuctionBid!] @derivedFrom(field: "auction")

  " Auction configuration "
  englishAuctionConfiguration: EnglishAuctionConfiguration!

  " Used only for collateral auctions. This is the Safe that got liquidated "
  safe: Safe

  " Timestamp of the block at which the auction started "
  createdAt: BigInt!

  " Block number at which the auction started "
  createdAtBlock: BigInt!

  " Hash of the transaction that started the auction "
  createdAtTransaction: Bytes!
}

# --- Discount Auction ---

type DiscountAuction @entity {
  " Equal to: <Auction house address>-<auction ID> "
  id: ID!

  " Auction incremental id "
  auctionId: BigInt!

  " Auction collateral type "
  collateralType: CollateralType!

  " Safe handler address in the SafeEngine "
  safeHandler: Bytes!

  " Total collateral for sale at the start of the auction "
  sellInitialAmount: BigDecimal!

  " Max amount of system coins to raise "
  amountToRaise: BigDecimal!

  " Amount of system coins raised so far "
  buyAmount: BigDecimal!

  " Cumulative collateral amount sold so far "
  sellAmount: BigDecimal!

  " Liquidated Safe "
  safe: Safe!

  " Address that started the auction "
  startedBy: Bytes!

  " Number of individual batches of collateral sold "
  numberOfBatches: BigInt!

  # " List of individual collateral batches that were sold "
  batchSold: [DiscountAuctionBatch!] @derivedFrom(field: "auction")

  " Whether there's still any collateral left to be bought "
  isTerminated: Boolean!

  " Whether the settle function that returns remaining collateral to the Safe was called "
  isSettled: Boolean!

  " Timestamp of the block in which the auction started "
  createdAt: BigInt!

  " Block number at which the auction started "
  createdAtBlock: BigInt!

  " Hash of the transaction that started the auction "
  createdAtTransaction: Bytes!
}

type DiscountAuctionBatch @entity {
  " Equal to: <Auction house address>-<auction id>-<batch number> "
  id: ID!

  " Incremental batch id "
  batchNumber: BigInt!

  " Auction in which the batch was sold "
  auction: DiscountAuction!

  " Amount of tokens bought in the batch "
  buyAmount: BigDecimal!

  " Amount of collateral sold in the batch "
  sellAmount: BigDecimal!

  " Collateral price "
  price: BigDecimal!

  " Bidder address "
  buyer: Bytes!

  " Timestamp of the block at which the batch was created "
  createdAt: BigInt!

  " Block number at which the batch was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that created the batch "
  createdAtTransaction: Bytes!
}

# --- ERC20 ---

type ERC20Balance @entity {
  "<tokenAddress>-<address>"
  id: ID!

  " Address of the ERC20 token "
  tokenAddress: Bytes!

  " Static label such as COIN, GOV, COIN_UNI_POOL to identify the asset "
  label: String

  " Address of the owner that has the balance "
  address: Bytes!

  " Either the address or the owner of the proxy if the address is a Proxy "
  owner: User!

  " Balance amount "
  balance: BigDecimal!

  " List of spend allowances (addresses that can spend the balance) "
  approvals: [ERC20Allowance!] @derivedFrom(field: "balance")

  " Timestamp of the block at which this balance was last modified [unix time] "
  modifiedAt: BigInt!

  " Block number at which this balance was last modified "
  modifiedAtBlock: BigInt!

  " Hash of the transaction that last modified the balance "
  modifiedAtTransaction: Bytes!
}

type ERC20Transfer @entity {
  " Equal to: <tx hash>-<log index> "
  id: ID!

  " Static label such as COIN, GOV, COIN_UNI_POOL to identify the asset "
  label: String

  " Address of the ERC20 token "
  tokenAddress: Bytes!

  " Source address "
  source: Bytes!

  " Destination address "
  destination: Bytes!

  " Amount transferred "
  amount: BigDecimal!

  " Timestamp of the block at which this transfer was created [seconds] "
  createdAt: BigInt!

  " Block number at which this transfer was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that created this transfer "
  createdAtTransaction: Bytes!
}

type ERC20Allowance @entity {
  " Equal to: <tokenAddress>-<allowedAddress>-<approvedAddress> "
  id: ID!

  " Address of the ERC20 token "
  tokenAddress: Bytes!

  " Static label such as COIN, GOV, COIN_UNI_POOL to identify the asset "
  label: String

  " Account that allows others to spend "
  address: Bytes!

  " Balance that can be spent "
  balance: ERC20Balance!

  " Address being approved to spend the balance "
  approvedAddress: Bytes!

  " Current token allowance "
  amount: BigDecimal!

  " Timestamp of the block at which this balance was last modified [unix time] "
  modifiedAt: BigInt!

  " Block number at which this balance was last modified "
  modifiedAtBlock: BigInt!

  " Hash of the transaction that last modified the allowance "
  modifiedAtTransaction: Bytes!
}

# --- Governance ---

type DsPauseScheduledTransaction @entity {
  " Equal to: <fullTransactionHash> "
  id: ID!

  " Address of the smart contract sending the proposal (e.g: multisig, vote quorum) "
  proposalSender: Bytes!

  " Transaction target "
  proposalTarget: Bytes!

  " Whether or not the transaction was executed "
  executed: Boolean!

  " Whether or not the transaction was abandoned "
  abandoned: Boolean!

  " Proposal transaction data "
  transactionData: Bytes!

  " Transaction code hash "
  codeHash: Bytes!

  " Earliest timestamp when this proposal can be executed "
  earliestExecutionTime: BigInt!

  " The proposal's full hash identifier "
  fullTransactionHash: Bytes!

  " The proposal's partial hash identifier "
  partialTransactionHash: Bytes!

  " Optional description for the proposal "
  transactionDescription: String

  " Timestamp of the block at which this transaction was created [unix time] "
  createdAt: BigInt!

  " Block number at which this transaction was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that created the proposal "
  createdAtTransaction: Bytes!
}

type GebAuthorization @entity {
  "<Contract address>-<Authorized account>"
  id: ID!

  " Contract address for the authorization "
  contract: Bytes!

  " Smart contract label "
  contractLabel: String

  " Authorized account address "
  account: Bytes!

  " Authorized account label "
  accountLabel: String

  " Whether the account is currently authorized or not (an authorization can be revoked) "
  isAuthorized: Boolean!

  " Timestamp of the block at which the authorization was created [unix time] "
  createdAt: BigInt!

  " Block number at which the authorization was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that created the authorization "
  createdAtTransaction: Bytes!

  " Timestamp of the block at which the authorization was last modified [unix time] "
  modifiedAt: BigInt

  " Block number at which the authorization was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash at which the authorization was last modified "
  modifiedAtTransaction: Bytes
}

# --- Uniswap ---

type UniswapPair @entity {
  " Pair address "
  id: ID!

  " Contract address of the pair "
  address: Bytes!

  " Pair name/label "
  label: String

  " Base token address "
  token0: Bytes!

  " Quote token address "
  token1: Bytes!

  " Base token reserve amount "
  reserve0: BigDecimal!

  " Quote token reserve amount "
  reserve1: BigDecimal!

  " reserve0 / reserve 1 "
  token0Price: BigDecimal!

  " reserve1 / reserve 0 "
  token1Price: BigDecimal!

  " Supply of pool token shares "
  totalSupply: BigDecimal!

  " Timestamp of the block at which the pair was created [unix time] "
  createdAt: BigInt!

  " Block number at which the pair was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that started to create the pair "
  createdAtTransaction: Bytes!

  " Timestamp of the block at which the pair was last modified [unix time] "
  modifiedAt: BigInt

  " Block number at which the pair was last modified "
  modifiedAtBlock: BigInt

  " Hash of the tx that last modified the pair "
  modifiedAtTransaction: Bytes
}

type UniswapSwap @entity {
  "<Tx hash>-<Log index>"
  id: ID!

  " Uniswap pair "
  pair: UniswapPair!

  " Address that made the swap "
  sender: Bytes!

  " Amount in token 0 "
  amount0In: BigDecimal!

  " Amount in token 1 "
  amount1In: BigDecimal!

  " Amount out token 0 "
  amount0Out: BigDecimal!

  " Amount out token 1 "
  amount1Out: BigDecimal!

  " Timestamp of the block at which the swap was made [seconds] "
  createdAt: BigInt!

  " Block number at which the swap was made "
  createdAtBlock: BigInt!

  " Hash of the transaction that created the swap "
  createdAtTransaction: Bytes!
}

type UniswapSync @entity {
  " <Tx hash>-<Log index> "
  id: ID!

  " Uniswap reserve of asset 0 "
  reserve0: BigDecimal!

  " Uniswap reserve of asset 1 "
  reserve1: BigDecimal!

  " Timestamp of the block at which the sync was made [unix time] "
  createdAt: BigInt!

  " Block number at which the sync was made "
  createdAtBlock: BigInt!

  " Hash of the transaction that executed the sync "
  createdAtTransaction: Bytes!
}

# --- Incentive ---

type IncentiveCampaign @entity {
  " <Address of the campaign contract> "
  id: ID!

  " Address of the campaign contract "
  campaignAddress: Bytes!

  " Campaign incremental ID "
  campaignNumber: BigInt!

  " Duration of the reward distribution "
  rewardsDuration: BigInt!

  " End of the reward distribution "
  periodFinish: BigInt!

  " Per second distributed reward "
  rewardRate: BigDecimal!

  " Total LP shares staked into the contract "
  totalSupply: BigDecimal!

  " Token being distributed "
  rewardToken: Bytes!

  " Token being staked "
  stakingToken: Bytes!

  " Last update date of rewardPerTokenStored "
  lastUpdatedTime: BigInt!

  " Cumulative per token reward distributed so far "
  rewardPerTokenStored: BigDecimal!

  " Timestamp of the block at which the campaign was made [unix time] "
  createdAt: BigInt!

  " Block number at which the campaign was made "
  createdAtBlock: BigInt!

  " Hash of the transaction that created the campaign "
  createdAtTransaction: Bytes!

  " Timestamp of the block at which the campaign was last modified [unix time] "
  modifiedAt: BigInt

  " Block number at which the campaign was last modified "
  modifiedAtBlock: BigInt

  " Hash of the transaction that was last to modify the campaign "
  modifiedAtTransaction: Bytes
}

type IncentiveBalance @entity {
  " <Campaign address>-<Staker address> "
  id: ID!

  " Staker address "
  address: Bytes!

  " Campaign number "
  campaignNumber: BigInt!

  " Campaign contract address "
  campaignAddress: Bytes!

  " Owner of the address (proxy owner if address is a proxy) "
  owner: User

  " Individual staker token balance in the contract "
  stakeBalance: BigDecimal!

  " Cumulative reward available to claim (does not include the reward since the last update) "
  reward: BigDecimal!

  " Paid out reward per token accumulated "
  userRewardPerTokenPaid: BigDecimal!

  " Timestamp of the block at which the campaign was made [unix time] "
  createdAt: BigInt!

  " Block number at which the staking balance was created "
  createdAtBlock: BigInt!

  " Hash of the transaction that created the staking balance "
  createdAtTransaction: Bytes!

  " Timestamp of the block at which the staking balance was last modified [unix time] "
  modifiedAt: BigInt

  " Block number at which the staking balance was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash at which the staking balance was last modified "
  modifiedAtTransaction: Bytes
}

# --- Periodic updates ---

type DailyStat @entity {
  " Block timestamp / 86400 "
  id: ID!

  " Time of the snapshot "
  timestamp: BigInt!

  " Block Number "
  blockNumber: BigInt!

  " Redemption rate "
  redemptionRate: RedemptionRate

  " Redemption price "
  redemptionPrice: RedemptionPrice

  " Price of COIN in USD (Uniswap pool price * ETH median price) "
  marketPriceUsd: BigDecimal!

  " Price of COIN in ETH (Uniswap v2 pool price) "
  marketPriceEth: BigDecimal!

  " Global debt "
  globalDebt: BigDecimal!

  " ERC20 COIN Supply "
  erc20CoinTotalSupply: BigDecimal!
}

type HourlyStat @entity {
  " Block timestamp / 86400 "
  id: ID!

  " Time of the snapshot "
  timestamp: BigInt!

  " Block Number "
  blockNumber: BigInt!

  " Redemption rate "
  redemptionRate: RedemptionRate

  " Redemption price "
  redemptionPrice: RedemptionPrice

  " Price of COIN in USD (Uniswap v2 pool price * ETH median price) "
  marketPriceUsd: BigDecimal!

  " Price of COIN in ETH (taken from the Uniswap v2 pool) "
  marketPriceEth: BigDecimal!

  " Global debt "
  globalDebt: BigDecimal!

  " ERC20 COIN Supply "
  erc20CoinTotalSupply: BigDecimal!
}
